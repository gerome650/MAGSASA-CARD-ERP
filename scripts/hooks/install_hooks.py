#!/usr/bin/env python3
"""
🔧 Hardened Git Hooks Installer

Installs production-hardened Git hooks with:
- Pre-commit quality checks (formatting, linting, tests, secrets detection)
- Post-push notifications (coverage tracking, merge scoring, Slack integration)
- Bypass detection and audit logging
- Rollback capabilities and integrity verification

Usage:
    python scripts/hooks/install_hooks.py          # Install hooks
    python scripts/hooks/install_hooks.py --uninstall  # Remove hooks
    python scripts/hooks/install_hooks.py --verify     # Verify installation
    python scripts/hooks/install_hooks.py --verbose    # Verbose output
"""

import argparse
import logging
import os
import shutil
import stat
import sys
from pathlib import Path

# Configure structured logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)


class GitHooksInstaller:
    """Hardened Git hooks installer with integrity verification."""

    def __init__(self, verbose: bool = False):
        """Initialize hooks installer.

        Args:
            verbose: Whether to enable verbose logging
        """
        self.verbose = verbose
        self.repo_root = Path(__file__).parent.parent.parent
        self.git_hooks_dir = self.repo_root / ".git" / "hooks"
        self.scripts_dir = self.repo_root / "scripts" / "hooks"
        self.backup_dir = self.repo_root / ".git" / "hooks.backup"

        # Hook configurations
        self.hooks_config = {
            "pre-commit": {
                "script": "pre_commit.py",
                "description": "Pre-commit quality checks",
                "required": True,
            },
            "post-push": {
                "script": "post_push.py",
                "description": "Post-push notifications",
                "required": False,
            },
        }

    def _ensure_git_repo(self) -> None:
        """Ensure we're in a Git repository."""
        if not (self.repo_root / ".git").exists():
            raise RuntimeError("Not in a Git repository. Run from repository root.")

        if not self.git_hooks_dir.exists():
            raise RuntimeError(f"Git hooks directory not found: {self.git_hooks_dir}")

    def _create_backup(self) -> None:
        """Create backup of existing hooks."""
        if self.backup_dir.exists():
            shutil.rmtree(self.backup_dir)

        self.backup_dir.mkdir(parents=True, exist_ok=True)

        for hook_name in self.hooks_config:
            hook_file = self.git_hooks_dir / hook_name
            if hook_file.exists():
                backup_file = self.backup_dir / hook_name
                shutil.copy2(hook_file, backup_file)
                if self.verbose:
                    logger.info(f"Backed up existing {hook_name} hook")

    def _create_hook_wrapper(self, hook_name: str, script_name: str) -> str:
        """Create a hardened hook wrapper script.

        Args:
            hook_name: Name of the Git hook
            script_name: Name of the Python script

        Returns:
            Content of the wrapper script
        """
        self.scripts_dir / script_name

        wrapper_content = f"""#!/bin/bash
# 🛡️ Hardened {hook_name} Hook Wrapper
# Auto-generated by install_hooks.py
# Do not edit manually - use install_hooks.py instead

set -euo pipefail

# Audit logging
echo "$(date -Iseconds) - {hook_name} hook triggered" >> .git/hooks/audit.log

# Check for bypass attempts
if [[ "$*" == *"--no-verify"* ]]; then
    echo "🚨 WARNING: --no-verify detected in {hook_name} hook!"
    echo "This bypasses governance policies and may violate compliance requirements."
    echo "Audit log: .git/hooks/audit.log"

    # Log bypass attempt
    echo "$(date -Iseconds) - BYPASS ATTEMPT: --no-verify used" >> .git/hooks/audit.log

    # In CI, fail on bypass attempts
    if [[ -n "${{CI:-}}" ]]; then
        echo "❌ --no-verify not allowed in CI environment"
        exit 1
    fi
fi

# Run the actual hook script
SCRIPT_DIR="${{BASH_SOURCE[0]%/*}}"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Change to repo root and run script
cd "$REPO_ROOT"
python3 "scripts/hooks/{script_name}" "$@"

# Capture exit code
EXIT_CODE=$?

# Log result
if [ $EXIT_CODE -eq 0 ]; then
    echo "$(date -Iseconds) - {hook_name} hook completed successfully" >> .git/hooks/audit.log
else
    echo "$(date -Iseconds) - {hook_name} hook failed with exit code $EXIT_CODE" >> .git/hooks/audit.log
fi

exit $EXIT_CODE
"""
        return wrapper_content

    def _install_hook(self, hook_name: str, config: dict) -> bool:
        """Install a single hook.

        Args:
            hook_name: Name of the Git hook
            config: Hook configuration

        Returns:
            True if successful
        """
        hook_file = self.git_hooks_dir / hook_name
        script_file = self.scripts_dir / config["script"]

        # Check if script exists
        if not script_file.exists():
            if config["required"]:
                logger.error(f"Required script not found: {script_file}")
                return False
            else:
                logger.warning(f"Optional script not found: {script_file}")
                return True

        try:
            # Create wrapper script
            wrapper_content = self._create_hook_wrapper(hook_name, config["script"])

            # Write hook file
            with open(hook_file, "w") as f:
                f.write(wrapper_content)

            # Make executable
            hook_file.chmod(hook_file.stat().st_mode | stat.S_IEXEC)

            if self.verbose:
                logger.info(f"Installed {hook_name} hook: {config['description']}")

            return True

        except Exception as e:
            logger.error(f"Failed to install {hook_name} hook: {e}")
            return False

    def _verify_installation(self) -> dict[str, bool]:
        """Verify hook installation integrity.

        Returns:
            Dictionary mapping hook names to verification status
        """
        verification_results = {}

        for hook_name, config in self.hooks_config.items():
            hook_file = self.git_hooks_dir / hook_name
            script_file = self.scripts_dir / config["script"]

            # Check if hook file exists and is executable
            if not hook_file.exists():
                verification_results[hook_name] = False
                continue

            if not os.access(hook_file, os.X_OK):
                verification_results[hook_name] = False
                continue

            # Check if script file exists (for required hooks)
            if config["required"] and not script_file.exists():
                verification_results[hook_name] = False
                continue

            # Check if hook contains our wrapper signature
            try:
                with open(hook_file) as f:
                    content = f.read()
                    if "Hardened" not in content or "install_hooks.py" not in content:
                        verification_results[hook_name] = False
                        continue
            except Exception:
                verification_results[hook_name] = False
                continue

            verification_results[hook_name] = True

        return verification_results

    def install(self) -> bool:
        """Install all hooks.

        Returns:
            True if all hooks installed successfully
        """
        try:
            self._ensure_git_repo()

            if self.verbose:
                logger.info("Installing hardened Git hooks...")

            # Create backup
            self._create_backup()

            # Install each hook
            success_count = 0
            total_count = len(self.hooks_config)

            for hook_name, config in self.hooks_config.items():
                if self._install_hook(hook_name, config):
                    success_count += 1

            # Verify installation
            verification_results = self._verify_installation()
            all_verified = all(verification_results.values())

            if self.verbose:
                logger.info(
                    f"Hook installation: {success_count}/{total_count} hooks installed"
                )
                logger.info(
                    f"Verification: {sum(verification_results.values())}/{total_count} hooks verified"
                )

            return success_count == total_count and all_verified

        except Exception as e:
            logger.error(f"Hook installation failed: {e}")
            return False

    def uninstall(self) -> bool:
        """Uninstall all hooks.

        Returns:
            True if all hooks uninstalled successfully
        """
        try:
            self._ensure_git_repo()

            if self.verbose:
                logger.info("Uninstalling Git hooks...")

            success_count = 0
            total_count = len(self.hooks_config)

            for hook_name in self.hooks_config:
                hook_file = self.git_hooks_dir / hook_name

                if hook_file.exists():
                    # Check if it's our hook
                    try:
                        with open(hook_file) as f:
                            content = f.read()
                            if "install_hooks.py" in content:
                                hook_file.unlink()
                                success_count += 1
                                if self.verbose:
                                    logger.info(f"Uninstalled {hook_name} hook")
                            else:
                                if self.verbose:
                                    logger.warning(
                                        f"Skipped {hook_name} hook (not installed by this tool)"
                                    )
                                success_count += (
                                    1  # Count as success since it's not ours
                                )
                    except Exception as e:
                        logger.error(f"Failed to uninstall {hook_name} hook: {e}")
                else:
                    success_count += 1  # Count as success if already removed

            if self.verbose:
                logger.info(
                    f"Hook uninstallation: {success_count}/{total_count} hooks processed"
                )

            return success_count == total_count

        except Exception as e:
            logger.error(f"Hook uninstallation failed: {e}")
            return False

    def verify(self) -> bool:
        """Verify hook installation.

        Returns:
            True if all hooks are properly installed and verified
        """
        try:
            self._ensure_git_repo()

            if self.verbose:
                logger.info("Verifying Git hooks installation...")

            verification_results = self._verify_installation()
            all_verified = all(verification_results.values())

            if self.verbose:
                for hook_name, verified in verification_results.items():
                    status = "✅ Verified" if verified else "❌ Failed"
                    logger.info(f"  {hook_name}: {status}")

            return all_verified

        except Exception as e:
            logger.error(f"Hook verification failed: {e}")
            return False


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(description="Hardened Git hooks installer")
    parser.add_argument("--uninstall", action="store_true", help="Uninstall hooks")
    parser.add_argument("--verify", action="store_true", help="Verify installation")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    args = parser.parse_args()

    installer = GitHooksInstaller(verbose=args.verbose)

    try:
        if args.verify:
            success = installer.verify()
        elif args.uninstall:
            success = installer.uninstall()
        else:
            success = installer.install()

        if success:
            if args.verify:
                print("✅ All hooks verified successfully")
            elif args.uninstall:
                print("✅ All hooks uninstalled successfully")
            else:
                print("✅ All hooks installed successfully")
            sys.exit(0)
        else:
            if args.verify:
                print("❌ Hook verification failed")
            elif args.uninstall:
                print("❌ Hook uninstallation failed")
            else:
                print("❌ Hook installation failed")
            sys.exit(1)

    except Exception as e:
        logger.error(f"Operation failed: {e}")
        if args.verbose:
            import traceback

            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
